p. 318		DML

 1. 삽입 insert
 2. 수정 update
 3. 삭제 delete


--------------------------------------
Transection	insert
 Start		insert
		insert
		update
		  . . .
---------------------------------------
		commit(저장)
       < DML - 한개의 트랜잭션 >



* 트랜잭션의 구분
 1. DML 문장 전체를 1개의 트랜잭션으로 관리
 2. DDL , DCL 명령문은 문장 하나가 1개의 트랜잭션으로 관리
 3. select 명령문은 트랜잭션에 포함되지 않음
 4. 트랜잭션이 종료되면 commit / rollback 중 한가지 현상 발생
  - commit - auto commit : 새로운 트랜잭션 시작 또는 프로그램 종료시 발생
	   - 수동 commit : commit 명령어를 실행
  - rollback - auto rollback : 프로그램의 비정상적인 종료
	   - 수동 rollback : rollback 명령어를 실행
    -> commit 한 데이터는 rollback 불가

p. 320

insert와 delete 는 행단위
update는 열단위로 작업한다

** insert : 테이블의 맨 마지막에 행을 추가한다. -------------------------------
  -> 절대 중간에 삽입 불가
  -> 한번에 한 행만 추가된다.

insert into   table_name
values        table에 삽입할 값 명시

insert into dept	 	-> dept 모든 컬럼에 값을 삽입하겠다
values

insert into dept(a,b,c,d)	-> 명시된 컬럼에만 값을 삽입하겠다
values

* 주의
 1. into절에 명시된 컬럼의 순서, 개수, 타입, 길이에 맞게
    value절에 data가 1:1로 매칭되어야 한다.
 2. PK 가 중복될 경우 에러남


** update ---------------------------------------------------------------------------
p. 330

update
set
where 특정행 수정시 사용
	안 쓰면 테이블의 모든 행 수정됨


**  delete ------------------------------------------------------------------------------
p. 335


delete
where	특정행 삭제
	안쓰면 테이블 전체 삭제



--------------------------------------------------------------------------------------------


- 부모 테이블은 자식테이블이 참조하고 있는한 수정이 힘들다


읽기 일관성
 -  현재 진행중인 트랜젝션을 다른 트랜젝션이 침범 불가 및 볼 수 없음
 - 

* 병행제어
 - 트랜잭션이 진행중인 행에 LOCK을 걸어 다른 트랜잭션이 침범하지 못하게 막음
 - 앞 트랜잭션이 완료되어야 뒤 트랜잭션이 작업을 할 수 있음


- 트랜잭션의 크기가 적을수록 LOCK 수가 많아 동시성이 커짐 -> 롤백 양이 적음
























